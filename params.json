{"name":"Trace Log to Sequence Diagram Generation","tagline":"Python scripts for converting trace log messages to sequence diagrams. Visually debug trace logs.","body":"# Trace Log to Sequence Diagram Conversion\r\n\r\nBrowsing through the code traces is an exercise in frustration. Applications produce huge logs that take\r\nhours to analyze. The Python scripts presented here let you visualize the traces as sequence diagrams. Interactions\r\nbetween objects are presented visually.\r\n\r\n## Step 1: Sample Trace to Sequence Diagram Conversion\r\n\r\nLet's get started by converting a sample trace into a sequence diagram. We start with downloading a few tools:\r\n\r\n1. Download and install a free 45 day trial of [EventStudio System Designer](http://www.EventHelix.com/EventStudio).\r\n1. Download and install [Python 2.7](http://www.python.org/getit/releases/2.7/)\r\n1. Download and extract the [trace to sequence diagram Python scripts](https://github.com/eventhelix/trace-to-sequence-diagram)\r\n   * Click the [ZIP](https://github.com/eventhelix/trace-to-sequence-diagram/zipball/master) button to download files.\r\n   * Alternatively click the \"Clone in Windows\" button. This would require downloading [GitHub for Windows](http://windows.github.com/)\r\n1. Before we proceed, please confirm the EventStudio path setting in the config.py file:\r\n\t* On machines running 64 bit Windows, the eventStudioPath Python variable should be set as:\r\n\r\n\t\teventStudioPath=r'\"C:\\Program Files (x86)\\EventHelix.com\\EventStudio System Designer 6\\evstudio.exe\"'\r\n\t* On 32 bits Windows platforms, eventStudioPath should be set as:\r\n\r\n\t\teventStudioPath=r'\"C:\\Program Files\\EventHelix.com\\EventStudio System Designer 6\\evstudio.exe\"'\r\n\r\n\t\t**Note:** If you get \"'C:\\Program' is not recognized as an internal or external command, operable program or batch file\" error, check if\r\n\t\tthe EventStudio path is correctly specifiedl\r\n\t\t\r\n1. Type cmd in the Run menu to invoke the Windows command prompt.\r\n1. Navigate to the directory where to the Python scripts for this project were downloaded.\r\n1. On the command line now type:\r\n\r\n\t**trace2sequence.py -i sample_trace.txt**  \r\n\r\n1. Click on the following generated diagrams:\r\n\t* **sequence-diagram.pdf** - A sequence diagram showing object level interactions\r\n\t* **component-level-sequence-diagram.pdf** - A high level sequence diagram that shows high level interactions\r\n\t* **context-diagram.pdf** - A context diagram of the object interactions.\r\n\t* **xml-export.xml** - XML representation of the object interactions. Use this XML output to develop your custom tools.\r\n\r\n\r\n## Step 2: Customize Regular Expressions to Map Traces to FDL (customize.py)\r\n\r\nBy now you would have seen a sequence diagram generated from the sample trace output. If you can modify your traces to \r\nmatch the trace output in sample_trace.txt you can skip this step.\r\n\r\nIn most cases however, there will be changes needed in config.py to map your trace format to the FDL input needed by EventStudio.\r\n\r\nThe config.py file lets you configure the trace to sequence diagram (FDL) mapping for:\r\n* Remarks that are shown on the right side of a sequence diagram\r\n* Message interactions\r\n* Method invoke and return\r\n* Object creation and deletion\r\n* Action taken by an object\r\n* State transition\r\n* Timer start, stop and expiry\r\n* Resource allocation and freeing\r\n\r\nWe will be mapping traces to FDL statements to generate the sequence diagrams. The mapping will also require a basic understanding\r\nof regular expressions. So let's visit these topics before we go any further.\r\n\r\n### Learning FDL - The Sequence Diagram Markup Language\r\n\r\nFDL (Feature Description Language) will be used to generate sequence diagrams. For a quick overview of FDL, refer to the\r\n[FDL sequence diagram tutorial](http://www.eventhelix.com/EventStudio/sequence-diagram-tutorial.pdf).\r\n\r\n### Python Regular Expressions\r\n\r\nThe Python website has a good [introduction to regular expressions](http://docs.python.org/library/re.html). [PythonRegEx.com](http://www.pythonregex.com/)\r\nis great for testing your regular expressions.\r\n\r\n### Templates and Regular Expressions\r\n#### Trace Template\r\nWe start with defining a regular expression that extracts information from the trace format. A\r\nregular expression that extracts trace information from sample_trace.txt is shown below:\r\n\r\n\t# The trace messages follow this high level format. The current regular expression\r\n\t# assumes that all traces are of the format:\r\n\t#\r\n\t# [time][generator][file]type body\r\n\t#\r\n\t# time:         The trace begins with time information in square brackets\r\n\t#\r\n\t# generator:    Entity generating the trace message. This may be a generic entity name.\r\n\t#               For C++ methods use the calling objects class name. For C functions\r\n\t#               the C function generating the trace would be mentioned here.\r\n\t#\r\n\t# file:         The next square bracket contains filename, line number information.\r\n\t#\r\n\t# type:         Defines the type of a trace. The type here is used to determine the\r\n\t#               mapping to an FDL statement. Refer to the traceMapper dictionary.\r\n\t#               traceMapper maps the type to the trace handler that will parse the\r\n\t#               trace body and extract information for generating an FDL statement.\r\n\t#\r\n\t# body:         This is the text following the type statement. Parsing of this text\r\n\t#               depends upon the type of the trace. This file contains the regular\r\n\t#               expression definitions for parsing of the body for different\r\n\t#               trace types.\r\n\r\n\ttraceRegex = '\\[(?P<time>.*)\\]\\s*\\[(?P<generator>.*)\\]\\[(?P<file>.*)\\]\\s*(?P<type>\\S+)\\s+(?P<body>.*)'\r\n\r\n#### Statement Templates\r\nIf you browse customize.py, you will see that the trace extraction regular expressions and the FDL statement generation templates\r\nare defined to next to each other. You would rarely need to change the FDL generation templates but they give you a context for\r\ndefining the regular expressions.\r\n\r\nRefer to the example below. invokeRegex regular expression extracts named fields, called, method and params. These fields along\r\nwith the caller are used in the FDL template.\r\n\r\n\t\t# Regular expression for parsing the function/method entry trace body\r\n\t\tinvokeMethodRegex = '(?P<called>\\w+)(\\.|::)(?P<method>\\w+)\\s*(\\((?P<params>\\w+)\\))?'\r\n\r\n\t\t# FDL mapping template for function/method entry\r\n\t\tinvokeTemplate = '{caller} invokes {called}.{method}{params}'\r\n\r\n## Optional Step 3: High Level Object Grouping and Bookmarks (customize.py)\r\n\r\nGenerated sequence diagrams can get complex in two ways:\r\n1. Diagrams are long and extend into several pages\r\n2. Too many interactive objects are present on a sequence diagram\r\n\r\n###Bookmarks\r\nThe first problem can be addressed by using bookmarks. Once you define bookmarks you will be able to navigate quickly to different parts \r\nof the sequence diagram. So add your important messages into the bookmark list. An example is shown below:\r\n\r\n\t\t# Add messages that need to be bookmarked in the PDF file. This is useful\r\n\t\t# as it lets to quickly navigate through the sequence diagram output of\r\n\t\t# a trace. PDF quick navigation bookmarks will be added whenever the messages\r\n\t\t# listed below are seen in the trace message.\r\n\t\tbookmarks = frozenset({\r\n\t\t\t'RandomAccessMessage',\r\n\t\t\t'RRCConnectionSetupComplete',\r\n\t\t\t'InitialUEMessage',\r\n\t\t\t'ReleaseConnection'\r\n\t\t})\r\n\r\n###Specify Object Groupings\r\nThe second issue highlighted above may be addressed by grouping objects. You can optionally specify the parents for objects in the customize.py file.\r\nEventStudio can use this information to generate a high level sequence diagram (Component Level Interaction Diagram).\r\n\r\nAn example of object grouping is shown in an excerpt from a sample customize.py :\r\n\r\n\t\t# EventStudio can generate a high level sequence diagram that can abstract\r\n\t\t# out a set of classes as a high level entity. This abstraction is useful in \r\n\t\t# understanding the trace output at a higher level of abstraction.\r\n\t\t#\r\n\t\t# List the interacting entities along with their parent. For example, the \r\n\t\t# tuples below indicate that DSP_01 and DSP_23 belong to the same high level PHY entity.\r\n\t\t# This means EventStudio will generate trace output at two levels:\r\n\t\t# - A sequence diagram where DSP_01 and DSP_23 show up as separate axis.\r\n\t\t# - A high level sequence diagram where PHY axis abstracts out the interactions\r\n\t\t#   involving DSP_01 and DSP_23\r\n\t\t# Just include the parent information for external actors in the system. Object parents\r\n\t\t# for internal actors are extracted from the trace contents.\r\n\t\tobjectParents = OrderedDict([\r\n\t\t\t# Tuples of object and its parent\r\n\t\t\t# (entity, parent)\r\n\t\t\t('DSP_01','PHY'),\r\n\t\t\t('DSP_23','PHY'),\r\n\t\t\t('CoreNetwork', 'EPC'),\r\n\t\t])\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}